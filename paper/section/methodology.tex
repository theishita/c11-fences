% --------- INTRO PART -------------
%\divComment{This para is motivation. Not needed here}
%We have developed a novel solution to the fence-synthesis problem. 
%To the best of our knowledge, 
%there are no push-button fence synthesis techniques for C11 
%programs as of now. Although, there are some such techniques for 
%other memory models, all of those heavily depends on the 
%possible set of reorderings allowed under the memory model. 
%Since the possible set of reorderings under C11 is different 
%than other memory models, these techniques cannot be applied 
%to C11 as is. In face, not all C11 behaviors can be justified 
%using reorderings and interleavings. Hence, automatic fence insertion 
%for C11 requires some amount of additional effort.

% Overview:
%% why only sc fences: if sc fence can't stop none can
%% brief overview of our approach
% Sections:
%% counter example generator and its specifications/requirements
%% inserting candidate fences and computing SO
%%% mention a trivial solution here
%% Fence minimization

In this section we discuss our approach of optimal \mosc fence synthesis 
in \cc programs. 
Our analysis focuses on \mosc fences since these are the strongest \cc 
fences. If a behavior cannot be stopped using \mosc fences, no combination 
of \cc fences can stop this behavior. 
In such cases, our approach proves that the behavior cannot be 
stopped using \cc fences.
Recall that \cc allows memory operations to be annotated with different 
memory orders. For the programs where buggy behavior cannot be stopped 
using fences, it is possible to stop the behavior by annotating some 
memory operations with stronger memory order.
Hence, we do not claim that if \ourtechnique cannot stop a buggy \cc 
execution, it cannot be stopped.
\divComment{Can we give termination guarantee?}

Unlike common fence synthesis approaches \divComment{Need references}, 
\ourtechnique does not try to \emph{add} fences optimally in a program.
Rather, it assumes that the input program has \mosc 
fences at all possible program locations, i.e, before and after every 
program instruction. We call these fences candidate fences. Our technique 
tries to \emph{remove} the unnecessary fences from the set of candidate 
fences based on axiomatic relations of \cc. 
Our approach grantees that the program resulted after removing the 
unnecessary fences, has minimal number of \mosc fences required in that 
program to stop the buggy executions. 

\ourtechnique takes a set of counter examples as input.
We use \cc 's $\setSB$, $\setHB$, $\setMO$, $\setRF$ relations to compute 
$ \setSO $-order assuming the existence of candidate fences.
We prove that the transitive closure of $ \setSO $-order is the same as 
$ \setTO $ in any valid \cc trace. 
Since $ \setTO $ is a total order, any valid \cc trace can not have a 
cycle formed by transitive sequence of ordered pair in $ \setSO $-order. 
We call such cycles $\setSO$-cycle. 
We use $ \setSO $-order and $ \setSO $-cycle to generate an SAT formula. 
Any satisfying assignment of this SAT formula is a possible fence 
placement to stop the buggy execution. We find the minimal satisfying assignment of this SAT formula to find optimal fence placement. 

\begin{algorithm}
	\caption{\ourtechnique}
	\begin{algorithmic}[1]	
		\Procedure{\ourtechnique}{$ P $}
		\State $\phi := \top$
		\State $ \mathcal{CE} := $CounterExampleGenerator($P$)
		\For{$ \tau \in \mathcal{CE} $}\Comment{$\tau$ = $ \langle \events_\tau, \setHB, \setMO, \setRF, \setSB  \rangle $}
			\State $ \events_{\im{\tau}} := \events_\tau\ \union $ candidate fences
			\State $ \seqb{\im{\tau}}{}{} := $ computeSB($\setSB, \events_{\im{\tau}}$) \State $ \so{\tau^{\mathtt{im}}}{}{} := $ computeSO($\events_{\im{\tau}}, \setHB, \setMO, \setRF, \seqb{\im{\tau}}{}{}$)
			\State cycles := computeCycles($ \so{\im{\tau}}{}{} $)
			\If {cycles == $ \emptyset $}
				\State \texttt{Abort} (``This behavior can't be stopped using \cc fences.'')
				\State \Return
			\EndIf
			\State $\phi := \phi\ \^ \formula{\so{\im{\tau}}{}{}} $ 
%			\State $ \phi := \phi_\tau $
		\EndFor
		\State F:= MinModel($ \phi $)
		\State \Return F
%		
%		\State create\_\z\_file()
%		\State fences\_required = run\_\z\_file()
%		\State insert\_into\_input\_file(fences\_required)
		\EndProcedure
		\label{alg:fence-syn}
	\end{algorithmic}
\end{algorithm}

The \ourtool uses Algorithm~\ref{alg:fence-syn} to insert fences in an 
input program $ P $. The algorithm start by initializing the 
SAT formula $ \phi $ with true.  Line 2 uses a counter-example generator 
to compute the set of counter examples in the program $ P $. 
Lines 4-12 generates SAT formula for each counter-example $ \tau $.
Lines 5 and 6 add candidate fences in the set of events of counter-example 
$ \tau $ and compute $ \lsb $ in the updated trace $ \im{\tau} $ (i.e., with candidate 
fences). 
Line 7 computes $ \so{\im{\tau}}{}{} $-order in counter example $ \tau $ with candidate fences.
Line 8 finds all $ \so{\im{\tau}}{}{} $-cycles. If there are no $ \so{\im{\tau}}{}{} $-cycles 
present, the behavior can't be stopped used any \cc fences. Hence, we 
terminate the algorithm at this point.
Else, in line 12, we generate a SAT formula for the set of $ \so{\im{\tau}}{}{} $-cycles and add it to formula $ \phi $
Lastly, in line 13 we find the minimal model of formula $ \phi $, which 
gives us the minimal set of fences to be inserted in order to stop the 
buggy behaviors.
The rest of this section discuss each of these steps in detail.

\subsection{Generating Counter Examples:} 
\ourtechnique requires a set of counter examples $ \mathcal{CE} $. 
Each of these counter-examples $ \tau $ should consist a list program events 
$ \events_\tau $ and $ \setHB, \setMO, \setRF, \setSB $ relations over the 
program events. 
A program event consists of instruction label, action, memory order, variable, and value. 
\divComment{We don't actually need value since we have rf and other relations already.}
Our approach treats a counter example generator that reports all of this information as a black box. 
Any technique that can generate \cc traces and find buggy behaviors can be used as counter-example generator.
%\divComment{Should we also include $ \setSB $ in counter example? Or we can assume it is available in $ \events_\tau $?}
Counter-examples in \texttt{dekker} program are given in 
Figure~\ref{fig:dekker-ce}. We have omitted \lsb, \lhb from the traces for 
simplicity. 

%%%% Move to motivation %%%%
%However, this comes at the cost of making program 
%stricter than required. Therefore, in our solution to retain maximum 
%flexibility, after inserting fences at all places, we must now eliminate 
%the ones which are not required and bring the number of fences down to 
%an optimum or minimum. To do this, we need to find relations between 
%all instructions and understand their semantics.
%
%The reason for choosing \mosc fences is that they are the strongest type 
%of fences, as seen in Fig \ref{fig:mo_strength}. In the program described 
%in Fig \ref{fig:dekker3}, the \moar fences cannot stop the buggy behavior.
%
%Another point to note is, inserting \mosc fences at all possible program 
%locations might not mean that the buggy behaviors are eliminated. 
%Therefore, our tool can only prevent the assertions from being violated 
%in cases where the behavior can be stopped using \mosc fences. Note that
%if a trace cannot be stopped by \mosc fence, then no C11 fence can stop 
%the trace. The tool also serves to minimize the total number of fences to 
%be added to the optimal number, thereby retaining the program behaviors 
%as relaxed as possible.
%%%%%%%%%%%%%%%%%%

\begin{figure}[!htb]
	\begin{center}
		\texttt{(Dekker)} \\ \ \\
		\begin{tabular}{l||l}
			$ \store{y}{1}{} $ & $ \store{x}{1}{} $ \\
			$ \load{a}{x}{} $ & $ \load{c}{y}{} $ \\
			\textbf{if} $ (a=0) $ & \textbf{if} $ (c=0) $ \\
			\quad $ \store{z}{1}{} $ & \quad $ \store{z}{2}{} $ \\
%			\quad $ \load{b}{z}{} $   & \quad$ \load{d}{z}{} $ \\
			\quad assert($ z=1 $) & \quad assert($ z=2 $) \\
		\end{tabular} 
%		\caption{Dekker's Mutual Exclusion program}\label{fig:dekker}
	\end{center}
\end{figure}

\begin{figure}[!h]
	\input{figures/dekker-ce1.tex}
	\input{figures/dekker-ce2.tex}
	\caption{Counter-examples in Dekker}
	\label{fig:dekker-ce}
\end{figure}

% --------------- FIG all pseudo fences -------------
%\begin{figure}[!htb]
%\begin{center}
%\texttt{
%init y := 0, x := 0;\\
%	\begin{tabular}{c l || c l}
%		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
%		(1) & W$\mathtt{_{rel}}$y(1) & (5) & W$\mathtt{_{rel}}$x(1)\\
%		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
%		(2) & if R$\mathtt{_{rel}x}$ == 0 & (6) & if R$\mathtt{_{rel}y}$ == 0\\
%		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
%		(3) & \qquad W$\mathtt{_{rel}}$c(1) & (7) & \qquad W$\mathtt{_{rel}}$c(0)\\
%		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
%		(4) & \qquad assert($\mathtt{R_{rel}c}$ == 1) & (8) & \qquad assert($\mathtt{R_{rel}c}$ == 0)\\
%		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
%	\end{tabular}
%}

%\divComment{All of the memory orders are rel. Is that correct?}
%	\caption{Dekker's Mutual Exclusion program}\label{fig:dekker3}
%\end{center}
%\end{figure}


\subsection{Computing SO relation}
\noindent\textbf{Inserting Candidate Fences:}
For each counter-example $ \tau $ of buggy program $ P $, we 
construct an intermediate trace $ \im{\tau} $ by assuming the existance candidate fences in the trace $ \tau $.
Our approach assumes all possible program locations as a valid location 
for candidate fences. 
Hence the $ \im{\tau} $ will have at least one \mosc fence before and after every program event in $ \tau $.
It is possible to start with a smaller set of program locations for 
candidate fences. 
In this case our approach will return the optimal fence placement wrt the 
set of candidate fences.
Since we are assuming existence of candidate fences at all possible 
program locations, the trace $ \im{\tau} $ should be invalid \cc execution 
if $ \tau $ can be stopped using \mosc fences.
Hence, if $ \im{\tau} $ is not invalid \cc execution for some 
the counter-examples $ \tau $ in $ \mathcal{CE} $, we determine that \mosc 
fences are not sufficient to stop the buggy behaviors of the program.
Recall that \mosc fences are the strongest \cc fences. 
If \mosc fences cannot stop a buggy behavior in a program, we can conclude 
that \cc fences are not strong enough to render this program correct.
Previous works \cite{LahavVafeiadis-PLDI17,Batty-POPL12} suggest that \mosc fences are not sufficient to achieve SC memory 
model. 
Hence it is possible that a valid SC program is buggy under \cc with all 
possible \mosc fences inserted. 
In some of these cases strengthening `the memory order annotated for some 
of the program instructions might render the program correct. 
However, strengthening the memory order annotation is out of the scope of this work. 

%\begin{figure}[!htb]
%	\begin{center}
%%		\texttt{(Dekker)} \\ \ \\
%		\begin{tabular}{l||l}
%			$ \fenceev{11} $ & $ \fenceev{21} $ \\
%			$ \store{y}{1}{} $ & $ \store{x}{1}{} $ \\
%			$ \fenceev{12} $ & $ \fenceev{22} $ \\
%			$ \load{a}{x}{} $ & $ \load{c}{y}{} $ \\
%			$ \fenceev{13} $ & $ \fenceev{23} $ \\
%			\textbf{if} $ (a=0) $ & \textbf{if} $ (c=0) $ \\
%			\quad $ \fenceev{14} $ & \quad $ \fenceev{24} $ \\
%			\quad $ \store{z}{1}{} $ & \quad $ \store{z}{2}{} $ \\
%			%			\quad $ \load{b}{z}{} $   & \quad$ \load{d}{z}{} $ \\
%			\quad $ \fenceev{15} $ & \quad $ \fenceev{25} $ \\
%			\quad assert($ z=1 $) & \quad assert($ z=2 $) \\
%			\quad $ \fenceev{16} $ & \quad $ \fenceev{26} $ \\
%		\end{tabular} 
%		\caption{Dekker with Candidate Fence}\label{fig:dekker-im}
%	\end{center}
%\end{figure}

\noindent\textbf{Computing \lsb in Intermediate Traces:} 
Line 5 of the Algorithm~\ref{alg:fence-syn} computes the set of program 
events in trace $ \im{\tau} $. Naturally, this set will consist of 
candidate fences along with all the program events in trace $ \tau $.
The set $ \setSB $ represents the pair of program events related by 
relation $ \lsb $ in the trace $ \tau $. We compute the set 
$ \seqb{\im{\tau}}{}{} $ for the events of the trace $ \im{\tau} $. 
The computeSB function takes set of \lsb event pairs in $ \tau $ 
($ \setSB $), the set of events in trace $ \im{\tau} $ 
($ \events_{\im{\tau}} $) as input and computes the set of \lsb in 
$ \im{\tau} $ based on instruction labels, their position in the program $ P $. \divComment{Do we need event action to compute the \lsb?}

\noindent\textbf{Computing \lso in Intermediate Traces:} 
%In \textsection\ref{sec:so theory}, we explain the rules to compute \lso relation given \lhb, \lmo, \lrf and \lsb relations. 
The line 7 of Algorithm~\ref{alg:fence-syn} uses the rules defined in 
\textsection\ref{sec:so theory} to compute the \lso relation in the trace 
$ \im{\tau} $ using the relations \lhb, \lmo, \lrf and \lsb. 
We use relations $ \setHB, \setMO, \setRF $ and $ \seqb{\im{\tau}}{}{} $ to compute $ \so{\im{\tau}}{}{} $.
Note that we have used the \lhb, \lmo and \lrf for trace $ \tau $ and \lsb 
for trace $ \im{\tau} $. 
Since \lmo is a relation between write events, fences will not be a part 
of it. Although, these fences may induce \lmo between some write event 
pairs in an actual execution. 
\divComment{How do we know these induces \lmo will not effect \lso?}
The same argument hold for \lrf relation as well.
\divComment{Need an argument for \lhb too.}
%We have already computed $ \seqb{\im{\tau}}{}{} $
 
\snj{Why hb, mo computed for $\tau$ and not $\im{\tau}$}\newline
Note that, the intermediate sequence $\im{\tau}$ may be invalid under 
\cc due to a possible cycle in the $\so{\im{\tau}}{}{}$ relation. 
As a result, the coherence rules of \cc do not apply to $\im{\tau}$. 
In the absence of \cc coherence rules the $\hb{\im{\tau}}{}{}$ and 
the $\mo{\im{\tau}}{}{}$ relations cannot be formed on the events of 
$\im{\tau}$.
%
Secondly, attempting to form $\hb{\im{\tau}}{}{}$ and 
$\mo{\im{\tau}}{}{}$ relations would modify the $\setHB$ and $\setMO$
effectively changing the buggy sequence $\tau$.

We, thus, only construct the relation $\so{\im{\tau}}{}{}$ and 
$\seqb{\im{\tau}}{}{}$ (needed for $\so{\im{\tau}}{}{}$) 
between the candidate fences inserted in $\im{\tau}$ and the events
of $\tau$. The two relations are sufficient as the goal is to
find $\so{\im{\tau}}{}{}$ cycle and invalidate the sequence under \cc.


\subsection{Reducing Fence Synthesis to SAT problem}
Recall that transitive closure of $ \so{\im{\tau}}{}{} $ is same as 
$ \to{\im{\tau}}{}{} $ in a valid \cc execution. Since  
$ \to{\im{\tau}}{}{} $ is a total order, a valid \cc execution should not 
have a cycle in $ \so{\im{\tau}}{}{} $. Conversely, if a trace has 
$ \so{\im{\tau}}{}{} $-cycle, it cannot be a valid \cc execution. 
In order to make a trace $ \tau $ invalid under \cc, we force a \lso-cycle by inserting appropriate fences. 
Since $ \im{\tau} $ assumes \mosc fences at all possible program locations,
any such cycle must exists in $ \so{\im{\tau}}{}{} $. 
Hence, our problem is reduced to finding appropriate cycle in 
$\so{\im{\tau}}{}{} $ and introducing these fences in the program to 
invalidate the trace $ \tau $.
If we introduced enough fences to cause at least \lso-cycle in 
every counter example, we stop all the buggy execution. 
It is possible that a counter example $ \tau $ does not have any 
$\so{\im{\tau}}{}{}$-cycles. Since $ \im{\tau} $ has \mosc fences at all 
possible program locations, we cannot add fences in such a trace to 
make it invalid \cc execution. 
Line 8 in Algorithm~\ref{alg:fence-syn} computes set $\so{\im{\tau}}{}{}$-cycles. 
The problem of finding cycles in a graph is well-studied area. Hence, we 
choose to skip the details of this step.
If there are no $\so{\im{\tau}}{}{}$-cycle in some $ \tau $, we conclude 
that it is not possible to stop this behavior using \cc fences in lines 
9-11.


Let $ \cycles{\im{\tau}} $ be the set of \lso-cycles in a trace $ \im{\tau} $, 
where a cycle $ c \in \cycles{\im{\tau}} $ is ordered sequence of 
$ \ordevents{\sc} $. We abuse the notation $\ordevents{\sc}_c$ to 
represent the set of events in a cycle $ c $. 
All the read and write events in $\ordevents{\sc}_c$ are already in program $ P $. 
Hence, to introduce a cycle $ c $ in the execution, we add the fences in $\ordevents{\sc}_c$, i.e, 
$\ordfences{\sc}_c$, in the program $ P $.
In other words, a cycle $ c $ can be introduced in a program if we insert 
$ (\bigwedge\limits_{f \in \ordfences{\sc}_c} f)$ fences in the program $ P $, 
where the truth assignment to a fence corresponds to inserting that fence 
in the program.
Recall that we need to stop at least one cycle from the set 
$ \cycles{\im{\tau}} $ in order to make a trace $ \tau $ invalid.
Hence we need to insert $ (\bigvee\limits_{c \in \cycles{\im{\tau}}} (\bigwedge\limits_{f \in \ordfences{\sc}_c} f)) $ to stop a trace $ \tau $. 
We use $\formula{\so{\im{\tau}}{}{}}$ to represent the boolean formula 
corresponding to the $ \so{\im{\tau}}{}{} $-cycles.
Clearly, any satisfying assignment to $ \formula{\so{\im{\tau}}{}{}} $ 
will give list of fences required to stop the buggy execution $ \tau $.
%
Furthermore, we construct the formula for all trace 
$ \tau \in \mathcal{CE} $ by conjuncting them in 
line 12 of Algorithm~\ref{alg:fence-syn}, i.e., 
at the end of the for loop in lines 4-12, the formula 
$ \phi \definedas (\bigwedge\limits_{\tau \in \mathcal{CE}} 
(\bigvee\limits_{c \in \cycles{\im{\tau}}} 
(\bigwedge\limits_{f \in \ordfences{\sc}_c} f))) $.
Any satisfying assignment of the formula $\phi$ will list the fences that 
are enough to stop the buggy behaviors in $ \mathcal{CE} $.

%\begin{lemma}
%	Introducing fences in any $\so{\im{\tau}}{}{}$-cycle will stop the counter example $ \tau $ in actual execution of the program.
%\end{lemma}

\begin{lemma}
	If there are no cycles in $\so{\im{\tau}}{}{}$ of a buggy execution 
	$\tau$, the counter-example $ \tau $ cannot be stopped using any \cc 
	fences.
\end{lemma}

\begin{theorem}
	Any satisfying assignment to $ \formula{\so{\im{\tau}}{}{}} $ 
	will give list of fences required to stop the buggy execution $ \tau $
\end{theorem}


\subsection{Finding Optimal Placement of the Fences}
One possible satisfying assignment to formula $ \phi $ is assigning the 
value true to all fences. Clearly such a solution is very expensive.
The number of truth assignments in the solution of formula $ \phi $ is 
equal to the number of fences inserted in the program.
%A satisfying assignment of the formula $ \phi $ with lesser number 
%of fences will give us a more optimal fence placement. 
Hence, a satisfying assignment of the formula $ \phi $ with the least 
number of fences will give us the optimal fence placement. 
Therefore, we reduce the problem of finding optimal fence placement to the 
minimal model of a SAT formula. 

The problem of minimal model computation has been studied in 
\divComment{need references}. \divComment{Need complexity argument for min model}.

In some cases, a fence at certain program location maybe more expensive 
than at other program location. For example, a fence inside a loop is may 
execute several times. Hence, such a fence may be more expensive than a 
fence placed outside the loop body.
%
\ourtechnique can handle such constraints by using weighted minimal model 
problem \divComment{need references}, where weight of each fence 
corresponds how expensive the fence is. 
The Algorithm~\ref{alg:fence-syn} can be modified to take weight 
function as input. 
%
The current implementation of \ourtechnique uses repeated calls to Z3 SAT 
solver to find the minimal model. \divComment{How are we solving it?}


\begin{theorem}
	For any input program $ P $, minimal model of $ \phi $ gives optimal
	number of fences required to stop all the buggy behaviors in 
	$ \mathcal{CE} $.
\end{theorem}

