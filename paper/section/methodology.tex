% --------- INTRO PART -------------
We have developed a novel solution to the fence-synthesis problem. We make use of the C11 semantics to create relations between the instructions and exploit the properties of these relations. We make use properties of Total Order relations and introduce ``cycles'' in the program to achieve our goal. We also achieve optimal results through a special process using propositional logic and SMT/SAT Solver Z3.
\ishComment{^^ rewrite}

The tool first begins by running the input program through a C11 model checker or verification tool. This tool runs all possible executions of the program and gives a list of buggy traces as output. A buggy trace here means an execution run where an assertion was violated in the program. The model checker provides the exact order of instructions, which when executed in the order can cause the program to stop mid-way by running into an assertion and not being able to satisfy it. The verification tool also provides the meta data for each instruction, such as read-from values or memory orders.

In the program described in Fig \ref{fig:dekker2}, inserting an SC fence between the instructions (1) and (2), and an SC fence between (5) and (6) render the program to be sequentially consistent, thereby satisfying the given assertions. After adding these fences, the program will never have a case where the output can be anything other than ``10''.

To obtain the position of these fences, a series of steps is followed. The two fences strategically inserted in the program are the minimum number of fences which can be inserted in order to prevent the unwanted outputs. One can add SC fences at all positions - before and after all instructions - in order to make the program sequentially consistent in nature and hence prevent the buggy outputs, such as in Fig \ref{fig:dekker3}. However, this comes at the cost of forgoing the properties of the relaxed model that the typical user tends to seek. Therefore, in our solution to retain concurrency, after inserting fences at all places, we must now eliminate the ones which are not required and bring the number of fences down to an optimum or minimum. To do this, we need to find relations between all instructions and understand their semantics.

The reason for choosing SC fences is that they are the strongest type of fences, as compared with fences of other memory orders, as seen in Fig \ref{fig:mo_strength}. In the program described in Fig \ref{fig:dekker3}, if the next strongest fence, the acquire-release fence replaces all SC fences, the behaviour where the assertions are violated will not be stopped. The assertions will still get violated.

Another point to note is, making the entire program sequentially consistent might not mean that the behaviour required by the user is retained. Even if the entire program is sequential after adding fences everywhere, the program still might fail certain assertions. This simply depends upon the program itself and how it runs. Therefore, our tool can only prevent the assertions from being violated in cases where the behaviour can be stopped using SC fences. The tool also serves to minimize the total number of fences to be added to the optimal number, thereby retaining the properties of concurrency as much as possible.

% --------------- FIG all pseudo fences -------------
\begin{figure}[!htb]
\begin{center}
\texttt{
init y := 0, x := 0;\\
	\begin{tabular}{c l || c l}
		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
		(1) & W$\mathtt{_{rel}}$y(1) & (5) & W$\mathtt{_{rel}}$x(1)\\
		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
		(2) & if R$\mathtt{_{rel}x}$ == 0 & (6) & if R$\mathtt{_{rel}y}$ == 0\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
		(3) & \qquad W$\mathtt{_{rel}}$c(1) & (7) & \qquad W$\mathtt{_{rel}}$c(0)\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
		(4) & \qquad assert($\mathtt{R_{rel}c}$ == 1) & (8) & \qquad assert($\mathtt{R_{rel}c}$ == 0)\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
	\end{tabular}
}
	\caption{Simple two-thread dekker program in C11 syntax with fences at each location}\label{fig:dekker3}
\end{center}
\end{figure}

% --------- ADDING FENCES -------------
\subsection{Adding Pseudo Fences}
\par
CDS Checker provides all the buggy traces to our tool. Each trace is then taken individually and analysed. For each trace, the first step is inserting pseudo fences. SC fences are inserted before/after each instruction in the trace. This can be seen in Fig. \ref{fig:dekker3}. The fences are not actually added to the input program, but only added for reference purposes as a step in the tool. The maximum number of fences possible are added so that the required ones can be retained and the rest can be eliminated.

% --------------- FINDING RELATIONS -----------
\subsection{Finding relations}
The basis of our approach lies upon finding relations between the instructions and figuring out how they affect the program in order to reduce the total fences to a minimum. For example, in Fig \ref{fig:dekker2}, if the assert statement is violated, this means that instructions (2) and (4) are reading from the initialized value and not the updated values, forming an rf (reads-from) relation.

\par
The next step after inserting pseudo fences is finding relations between instructions, including fences. These relations will help in figuring out which fences to eliminate from the trace. In particular, we are concerned with the TO (Total Order) relations between all SC instructions and fences. Rules for TO relations for the C11 model are described in the official standard \ishComment{cite here}. These rules are dependent upon a number of different relations which would have to be computed first, and an order is followed for the same.

% --------------- HB -----------------
\subsubsection{Finding HB relations}
The first and most basic relation is HB (happens-before). An instruction A is said to happen-before B if:\\
(\sw{A}{B}) $\lor$ (\seqb{A}{B}) $\lor$ (\hb{A}{X} $\land$ \hb{X}{B}) $\implies$ \hb{A}{B}

\par
Therefore, SB and SW relations are computed first. An SB relation is formed when an instruction comes before another in the same thread. An SW relation is formed based on the following rules:
\begin{enumerate}
\item SW relation between thread create and thread start instructions\\
\sw{thread A create}{thread A start}

\item SW relation between thread finish and thread join instructions\\
\sw{thread A finish}{thread A join}

\item SW relation between read (R) and write (W) instructions.\\
\rf{$W_{\geq rel}x$}{$R_{\geq acq}x$} $\implies$ \sw{$W_{\geq rel}x$}{$R_{\geq acq}x$}\\
RMW operations are considered as both reads and writes in this case.
\end{enumerate}

\par
These relations, since there are many, are stored as boolean values in an adjacency table, as opposed to the "list of tuples" format used for all other relations in the tool. The adjacency table is indexed based on the instruction number as given by CDS Checker. An example can be seen in Fig \ref{fig:cds_hb}. The 0 index is left out as empty and filled with 0's, while a 1 for row 3 column 4 would mean \hb{3}{4}.

% --------------- FIG --------------
%\begin{figure}
%\begin{center}
%	\input{section/hb_instr_example.tex}
%	\caption{a. Example instruction trace from CDS Checker.\\b. Adjacency table of hb relations as formed by the tool.}
%	\label{fig:cds_hb}
%\end{center}
%\end{figure}

\par
The HB relation is computed for all instructions before inserting the pseudo fences in the tool. This is because the HB relation is only required to compute the MO (modification order) relations, which only are only concerned with the write instructions. Therefore, computing HB relations before inserting pseudo fences everywhere makes the tool faster.

% --------------- MO ------------
\subsubsection{Finding MO relations}
MO (modification order) relations are formed between write instructions when the value of a variable is changed at some point in the program. The rules for modification order as described by the standard are:
\begin{enumerate}
    \item Write-write coherence: \\
    \hb{$A_x$}{$B_x$} $\implies$ \mo{$A_x$}{$B_x$}\\
    \textit{where A, B are write operations modifying variable x}
    
    \item Read-read coherence:\\
    \hb{\rf{$X_x$}{$A_x$}}{$B_x$} $\implies$ (\rf{$X_x$}{$B_x$}) $\lor$\ (\rf{\mo{$X_x$}{$Y_x$}}{$B_x$})\\
    \textit{where X, Y are writes on x\\ and A, B are reads on x}
    
    \item Read-write coherence:\\
    \hb{$A_x$}{$B_x$} $\implies$ (\rf{$X_x$}{$A_x$}) $\land$\ (\mo{$X_x$}{$B_x$})\\
    \textit{where X, B are writes on variable x\\and A is a read on variable x}
    
    \item Write-read coherence:\\
    \hb{$X_x$}{$B_x$} $\implies$ (\rf{$X_x$}{$B_x$}) $\lor$\ (\rf{\mo{$X_x$}{$Y_x$}}{$B_x$})\\
    \textit{where X, Y are writes on variable x\\and B is a read on variable x}
\end{enumerate}

\par
After this step, the pseudo fences are inserted.

% --------------- TO -----------
\subsubsection{Finding TO relations between SC instructions}\label{to_rel}
The final step in finding relations and the main step that is required for fence elimination is to find TO relations. The rules for TO relations in the C11 standard are defined in \ishComment{insert C11 std ref}. These rules can be interpreted as the following:
\input{section/to_rules.tex}
\textit{Note: ``the fence above instruction A'' is a comprehensive term for all the fences which are above instruction A.}

% --------------- SOLN EXPLAINED -------------
\subsection{Eliminating Fences}
Finally, we take into account the TO relations along with SB's between SC instructions. These relations combined provide us with all direct TO relations between all instructions and fences. Direct relations mean that these are the basic relations that are formed through only the rules. Transitive relations are the other kind of relations which can also be formed through transitive edges. We now get a graph that would look like Fig \ref{fig:cycles}.

\par
The purpose of creating a graph this way is to detect if there are any cycles formed in the trace after inserting the fences. In a total order relation, the antisymmetry and connexity properties state that:\\
Either \too{A}{B} or \too{B}{A} and if (\too{A}{B} $\land$ \too{B}{A}) then A = B.\\
This property of TO can be exploited to minimize the fences. According to the C/C++11 standard, each SC instruction is in total order with every other SC instruction. This means that for any two SC instructions A and B, either \too{A}{B} or \too{B}{A}. According to TO rules, if both of these relations hold true, then A = B. If A != B and A and B are different entities which satisfy the relation (\too{A}{B} $\land$ \too{B}{A}), that means that a cycle is formed between instructions A and B. This, in turn, violates the TO property, rendering the execution infeasible. If a certain execution becomes infeasible, then it would never be run.

% --------------- FIG 5 -------------------
\begin{figure}
\begin{center}
	\input{section/cycle_example.tex}
	\caption{A graph structure created by various relations acting as edges}
	\label{fig:cycles}
\end{center}
\end{figure}

\subsubsection{why transitive TO edges aren't considered}
The relations which are considered to form the final graph are - all SB edges between only SC instructions including transitive SB edges, and directly formed TO edges but not transitively formed TO edges. That is, all SB edges are taken into consideration whether immediate or not, and only those edges formed via the TO rules discussed in section \ref{to_rel} are considered while forming a graph. This is because transitively formed TO relations will be of no use in our case. If there is a transitive TO relation formed between two instructions, then this relation has been caused by fences introduced in the program. Therefore, for this transitive relation, we need not consider the two nodes participating in the transitive edge, instead we need to consider the original nodes which caused this transitive relation to form in the first place. Transitive edges are formed through transitive relations which will hide the originally formed TO relations. But by excluding the original edges, the transitive edges we need will never actually be formed.



\par
So even if transitive TO relations are considered as graph edges, they would not be directly used to obtain our final solution. For each transitively formed edge, all original edges which would have possibly caused the transitive edge would be needed to be kept track of. Therefore, using just the original edges serves our purpose in a much more efficient manner.

\subsection{Restricting Buggy Executions}
\par
We find out TO relations in only the buggy or erroneous traces which are obtain from CDS Checker. For each erroneous trace, a graph is formed with the instructions/fences as nodes and the TO relations as edges. Fences are introduced at places which form cycles in the graph. When the cycle is introduced, then it violates the properties of a total order relation in C11, rendering the entire execution order infeasible. An infeasible execution will never occur during runtime, which means that the buggy execution in which the TO cycle is introduces using fences will never be executed. Hence the assertion which was being violated will remain satisfied. 

In case there are no cycles forming for one or more of the buggy traces, the behaviour is deemed to be unpreventable using SC fences. 

\par
In Fig \ref{fig:cycles}, a number of cycles can be noted. Some of them are:
\begin{itemize}
\item \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$}
\item \textit{$F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2$}
\item \textit{$F_1n_1 \rightarrow I_1n_1 \rightarrow F_2n_2 \rightarrow F_3n_2 \rightarrow F_1n_1$}
\item \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$}
\end{itemize} 
A single cycle out of the above mentioned or others being formed needs to be implemented in order to prevent this particular execution run from ever taking place. From just looking over it once, one can notice that the smallest cycle would be \textit{$F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2$} with just two participating nodes. However, the cycle with the least number of fences is \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$} with just one fence (\textit{$F_2n_2$}) being inserted. Hence, if just \textit{$F_2n_2$} is inserted into the program, this particular buggy trace will be stopped. This method is carried out for all such buggy traces and their cycles are calculated and stored.

% --------------- FENCE MIN PROBLEM ----------
\subsection{The fence minimization problem}
\par
Even if cycles are calculated for each trace, the solution for obtaining a minimized number of fences to be inserted is not so straight-forward as simply choosing the one with the minimum fences for each trace. For one, there might be multiple cycles containing minimum fences. Another issue is that this would not yield the actual minimized number of fences. 

% --------------- FIG 6 -------------------
\begin{figure}
\begin{center}
	Cycles from trace 1:\\
	\textit{$F_1 \rightarrow F_2 \rightarrow F_1$}\\
	\textit{$F_3 \rightarrow F_4 \rightarrow F_1 \rightarrow F_3$}\\
	Cycles from trace 2:\\
	\textit{$F_3 \rightarrow F_4 \rightarrow F_3$}
	\caption{Example cycles from traces}
	\label{fig:fence_min}
\end{center}
\end{figure}

Fig \ref{fig:fence_min} shows cycles from two buggy traces from a program. Because of re-ordering and branching, the fence names might differ for each trace while mapping back to the source program. For example \textit{$F_1n_5$} may come after line 12 for trace 3 and line 15 for trace 4. For the purpose of this example, let us assume each fence to be a position in the original source code instead of it being a fence position in a single trace. This way, fence \textit{$F_4$} is the same fence for both the traces with respect to its position in the source code.

\par
The original solution to obtain the minimum number of fences was to take the smallest cycle from each trace, that is to take the cycle which contains the least number of fences from each execution trace. In this case, fences \textit{$F_1$}, \textit{$F_2$} would be chosen from trace 1 and fences \textit{$F_3$}, \textit{$F_4$} would be chosen from trace 2. This makes four total fences that to include in the main program to stop the behaviour where any assertion gets violated.

\par
However, this is not the optimal solution. Fig \ref{fig:fence_form} shows the example explained in Fig \ref{fig:fence_min} converted into its respective formula in propositional logic. For each trace, the cycles are added as disjunctions, with each fence in a cycle being a necessary component, deeming it a conjunction. Since each trace needs to satisfy at least one cycle for the trace to become infeasible, each cycle is a disjunction. All traces need to be prevented, so each trace is part of a conjunction.

% --------------- FIG 7 -----------------
\begin{figure}
\begin{center}
	( ( $F_1 \land F_2\ ) \lor\ ( F_3 \land F_4 \land F_1\ )\ ) \land\ (\ (\ F_3 \land F_4$ ) )
	\caption{Formula for Fig \ref{fig:fence_min}}
	\label{fig:fence_form}
\end{center}
\end{figure}

\par
Fig \ref{fig:fence_form} can be looked at as a cost function to minimize the cost, with each entity being a fence, having value either 0 or 1. A fence having value 1 would mean that it should be inserted in the program and value 0 would mean that it should not be inserted in the program, according to the minimized cost. From this formula, the solution for Fig \ref{fig:fence_min} comes out to have 3 fences â€“ \textit{$F_3, F_4, F_1$}, unlike the original solution where four fences were sought.

\par
Implementing such a propostional formula for programs with more than 50 execution traces, with each of them having uncountable fences would be quite an overhead. An SMT/SAT Solver is used for this purpose. Z3 SAT Solver is implemented in our tool. A formula similar to the one in Fig \ref{fig:fence_form} is created for each program and the minimum cost with the maximum satisfying solution is computed. 

\input{section/algo_figure.tex}
