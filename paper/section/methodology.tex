% --------- INTRO PART -------------
%\divComment{This para is motivation. Not needed here}
%We have developed a novel solution to the fence-synthesis problem. 
%To the best of our knowledge, 
%there are no push-button fence synthesis techniques for C11 
%programs as of now. Although, there are some such techniques for 
%other memory models, all of those heavily depends on the 
%possible set of reorderings allowed under the memory model. 
%Since the possible set of reorderings under C11 is different 
%than other memory models, these techniques cannot be applied 
%to C11 as is. In face, not all C11 behaviors can be justified 
%using reorderings and interleavings. Hence, automatic fence insertion 
%for C11 requires some amount of additional effort.

% Overview:
%% why only sc fences: if sc fence can't stop none can
%% brief overview of our approach
% Sections:
%% counter example generator and its specifications/requirements
%% inserting candidate fences and computing SC
%%% mention a trivial solution here
%% Fence minimization

In this section we discuss our approach of optimal \mosc fence synthesis 
in \cc programs. 
Our analysis focuses on \mosc fences since these are the strongest \cc 
fences. If a behavior cannot be stopped using \mosc fences, no combination 
of \cc fences can stop this behavior. 
In such cases, our approach proves that the behavior cannot be 
stopped using \cc fences.
Recall that \cc allows memory operations to be annotated with different 
memory orders. For the programs where buggy behavior cannot be stopped 
using fences, it is possible to stop the behavior by annotating some 
memory operations with stronger memory order.
Hence, we do not claim that if \ourtechnique cannot stop a buggy \cc 
execution, it cannot be stopped.
\divComment{Can we give termination guarantee?}

Unlike common fence synthesis approaches \divComment{Need references}, 
\ourtechnique does not try to \emph{add} fences optimally in a program.
Rather, it assumes that the input program has \mosc 
fences at all possible program locations, i.e, before and after every 
program instruction. We call these fences candidate fences. Our technique 
tries to \emph{remove} the unnecessary fences from the set of candidate 
fences based on axiomatic relations of \cc. 
Our approach grantees that the program resulted after removing the 
unnecessary fences, has minimal number of \mosc fences required in that 
program to stop the buggy executions. 

\ourtechnique takes a set of counter examples as input.
We use \cc 's $ \setSB, \setHB, \setMO, \setRF $ relations to compute 
$ \setSO $-order assuming the existence of candidate fences.
We prove that the transitive closure of $ \setSO $-order is the same as 
$ \setTO $ in any valid \cc trace. 
Since $ \setTO $ is a total order, any valid \cc trace can not have a 
cycle formed by transitive sequence of ordered pair in $ \setSO $-order. 
We call such cycles $\setSO$-cycle. 
We use $ \setSO $-order and $ \setSO $-cycle to generate an SAT formula. 
Any satisfying assignment of this SAT formula is a possible fence 
placement to stop the buggy execution. We find the minimal satisfying assignment of this SAT formula to find optimal fence placement. 

\begin{algorithm}
	\caption{\ourtechnique}
	\begin{algorithmic}[1]	
		\Procedure{\ourtechnique}{$ P $}
		\State $\phi := \top$
		\State $ \mathcal{CE} := $CounterExampleGenerator($P$)
		\For{$ \tau \in \mathcal{CE} $}
			\State $ \events_\tau^f := \events_\tau\ \union $ candidate fences
			\State $ \seqb{\tau'}{}{} := $ computeSB($\events_\tau^f$) \State $ \so{\tau'}{}{} := $ computeSO($\events_\tau^f, \setHB, \setMO, \setRF, \seqb{\tau'}{}{}$)
			\State cycles := computeCycles($ \so{\tau'}{}{} $)
			\If {cycles == $ \emptyset $}
				\State ``This behavior can't be stopped using \cc fences.''
				\State \Return
			\EndIf
			\State $\phi := \phi\ \^ $ genFormula(cycles)
%			\State $ \phi := \phi_\tau $
		\EndFor
		\State F:= MinModel($ \phi $)
		\State \Return F
%		
%		\State create\_z3\_file()
%		\State fences\_required = run\_z3\_file()
%		\State insert\_into\_input\_file(fences\_required)
		\EndProcedure
		\label{alg:fence-syn}
	\end{algorithmic}
\end{algorithm}

The \ourtool uses Algorithm~\ref{alg:fence-syn} to insert fences in an 
input program $ P $. The algorithm start by initializing the 
SAT formula $ \phi $ with true.  Line 2 uses a counter-example generator 
to compute the set of counter examples in the program $ P $. 
Lines 4-12 generates SAT formula for each counter-example $ \tau $.
Lines 5 and 6 add candidate fences in the set of events of counter-example 
$ \tau $ and compute $ \lsb $ in the updated trace (i.e., with candidate 
fences). 
\divComment{I wrote it as $ \seqb{\tau'}{}{} $ since it can't be parameterized with $ \tau $}.
Line 7 computes $ \so{\tau'}{}{} $-order in counter example $ \tau $ with candidate fences.
Line 8 finds all $ \so{\tau'}{}{} $-cycles. If there are no $ \so{\tau'}{}{} $-cycles 
present, the behavior can't be stopped used any \cc fences. Hence, we 
terminate the algorithm at this point.
Else, in line 12, we generate a SAT formula for the set of $ \so{\tau'}{}{} $-cycles and add it to formula $ \phi $
Lastly, in line 13 we find the minimal model of formula $ \phi $, which 
gives us the minimal set of fences to be inserted in order to stop the 
buggy behaviors.
The rest of this section discuss each of these steps in detail.

\noindent\textbf{Generating Counter Examples:} 
\ourtechnique requires a set of counter examples $ \mathcal{CE} $. 
Each of these counter-examples $ \tau $ should consist a list program events 
$ \events_\tau $ and $ \setHB, \setMO, \setRF, \setSB $ relations over the 
program events. 
A program event consists of instruction label, action, memory order, variable, and value. 
\divComment{We don't actually need variable and value since we have rf and other relations already.}
Our approach treats a counter example generator that reports all of this information as a black box. 
Any technique that can generate \cc traces and find buggy behaviors can be used as counter-example generator.
%\divComment{Should we also include $ \setSB $ in counter example? Or we can assume it is available in $ \events_\tau $?}
Counter-examples in \texttt{dekker} program are given in Figure~\ref{fig:dekker-ce}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%In the program described in Fig \ref{fig:dekker2}, inserting an SC fence 
%between the instructions (1) and (2), and an SC fence between (5) and (6) 
%render the program non-buggy, thereby satisfying the given assertions. 
%After adding these fences, the program will never have a case where 
%the output can be anything other than ``10''. 

%To obtain the position of these fences, a series of steps is followed. 
%The two fences strategically inserted in the program are the minimum 
%number of fences which can be inserted in order to prevent the unwanted 
%outputs. \snj{Not correct: 
%	One can add \mosc fences at all positions - before and after all 
%instructions - in order to make the program as strict as possible under 
%C11} and hence prevent the buggy outputs if possible, such as in Fig 
%\ref{fig:dekker3}. 

%%%% Move to motivation %%%%
%However, this comes at the cost of making program 
%stricter than required. Therefore, in our solution to retain maximum 
%flexibility, after inserting fences at all places, we must now eliminate 
%the ones which are not required and bring the number of fences down to 
%an optimum or minimum. To do this, we need to find relations between 
%all instructions and understand their semantics.
%
%The reason for choosing \mosc fences is that they are the strongest type 
%of fences, as seen in Fig \ref{fig:mo_strength}. In the program described 
%in Fig \ref{fig:dekker3}, the \moar fences cannot stop the buggy behavior.
%
%Another point to note is, inserting \mosc fences at all possible program 
%locations might not mean that the buggy behaviors are eliminated. 
%Therefore, our tool can only prevent the assertions from being violated 
%in cases where the behavior can be stopped using \mosc fences. Note that
%if a trace cannot be stopped by \mosc fence, then no C11 fence can stop 
%the trace. The tool also serves to minimize the total number of fences to 
%be added to the optimal number, thereby retaining the program behaviors 
%as relaxed as possible.
%%%%%%%%%%%%%%%%%%

\begin{figure}[!htb]
	\begin{center}
		\texttt{(Dekker)} \\ \ \\
		\begin{tabular}{l||l}
			$ \store{y}{1}{} $ & $ \store{x}{1}{} $ \\
			$ \load{a}{x}{} $ & $ \load{c}{y}{} $ \\
			\textbf{if} $ (a=0) $ & \textbf{if} $ (c=0) $ \\
			\quad $ \store{z}{1}{} $ & \quad $ \store{z}{2}{} $ \\
%			\quad $ \load{b}{z}{} $   & \quad$ \load{d}{z}{} $ \\
			\quad assert($ z=1 $) & \quad assert($ z=2 $) \\
		\end{tabular} 
%		\caption{Dekker's Mutual Exclusion program}\label{fig:dekker}
	\end{center}
\end{figure}

\begin{figure}[!h]
	\input{figures/dekker-ce1.tex}
	\input{figures/dekker-ce2.tex}
	\caption{Counter-examples in Dekker}
	\label{fig:dekker-ce}
\end{figure}

%% dekker for cppmem:
%int main() {
%	atomic_int x = 0; 
%	atomic_int y = 0;
%	atomic_int z = 0;
%	{{{ {
%					y.store(1, mo_relaxed);
%					if (x.load(mo_relaxed).readsvalue(0)) {
%						z.store(1, mo_relaxed);
%						z.load(mo_relaxed).readsvalue(1);
%					}
%				}
%				||| {
%					x.store(1, mo_relaxed);
%					if (r1=y.load(mo_relaxed).readsvalue(0)) {
%						z.store(2, mo_relaxed);
%						z.load(mo_relaxed).readsvalue(2);
%					}
%				}
%	}}};
%	return 0; 
%}



% --------------- FIG all pseudo fences -------------
\begin{figure}[!htb]
\begin{center}
\texttt{
init y := 0, x := 0;\\
	\begin{tabular}{c l || c l}
		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
		(1) & W$\mathtt{_{rel}}$y(1) & (5) & W$\mathtt{_{rel}}$x(1)\\
		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
		(2) & if R$\mathtt{_{rel}x}$ == 0 & (6) & if R$\mathtt{_{rel}y}$ == 0\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
		(3) & \qquad W$\mathtt{_{rel}}$c(1) & (7) & \qquad W$\mathtt{_{rel}}$c(0)\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
		(4) & \qquad assert($\mathtt{R_{rel}c}$ == 1) & (8) & \qquad assert($\mathtt{R_{rel}c}$ == 0)\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
	\end{tabular}
}

\divComment{All of the memory orders are rel. Is that correct?}
	\caption{Dekker's Mutual Exclusion program}\label{fig:dekker3}
\end{center}
\end{figure}

% --------- ADDING FENCES -------------
\subsection{Adding Pseudo Fences}
\par
We use a verification tool to generate a set of all the buggy traces. 
Each trace is then taken individually and analyzed. For each trace, 
the first step is inserting pseudo fences. \mosc fences are inserted 
before/after each instruction in the trace. This can be seen in 
Fig. \ref{fig:dekker3}. The fences are not actually added to the 
input program, but only added for reference purposes as a step in 
the tool. The maximum number of fences possible are added so that 
the required ones can be retained and the rest can be eliminated.

% --------------- FINDING RELATIONS -----------
\subsection{Finding relations}
% What is TO?
The C11 standard \cite{C11} states that in any valid execution 
all the \mosc instructions should form a total order. Such total order
has to be consistent with modification order and 
happens-before relation. This means that for any two \mosc instructions A 
and B such that A $ \neq B $, either $\to{\tau}{A}{B}$ or $\to{\tau}{B}{A}$. 
Hence, an execution with both $\to{\tau}{A}{B}$ and $\to{\tau}{B}{A}$ is infeasible.
% Why TO?
Our technique computes $\setSO$ of buggy execution when pseudo fences are 
present. If such $\setSO$ has a cycle, then the program with these fences 
will not have this buggy execution. 
Hence, by finding these cycles we can work out the required fences.
% Example
For example, in Fig \ref{fig:dekker2}, if the assert statement is violated
if either thread reads the value written to variable $c$ by the other thread.
% Other relations
%In order to find $\setSO$, we first compute the $\setSB$, $\setSW$, $\setHB$ and 
%$\setMO$ relations.
The basis of our approach lies upon finding relations between the 
instructions and figuring out how they affect the program in order to 
reduce the total fences to a minimum. 

\par
The next step after inserting pseudo fences is finding relations between 
instructions, including fences. 
These relations will help in figuring out which fences to eliminate from 
the trace. In particular, we are concerned with the $\setSO$ (total order) 
relations between all SC instructions and fences. Rules for TO relations 
for the C11 model are described in the official standard \cite{C11}. 
These rules are dependent relations $\setSO $, $\setSW$, $\setHB$ and $\setMO$, which 
would have to be computed first, and an order is followed for the same.

% --------------- HB -----------------
\subsubsection{Finding $\setHB$ relations}
The first and most basic relation is $\setHB$ (happens-before). 
An instruction A is said to happen-before B if:\\
($\sw{\tau}{A}{B}$) $\lor$ ($\seqb{\tau}{A}{B}$) $\lor$ ($\hb{\tau}{A}{X}$ $\land$ $\hb{\tau}{X}{B}$) $\implies$ $\hb{\tau}{A}{B}$

\par
Therefore, $\setSB$ (sequenced-before) and $\setSW$ (synchronizes-with) 
relations are computed first. 
An $\setSW$ relation is formed based on the following rules:
\begin{enumerate}
\item $\setSW$ relation between thread create and thread start instructions\\
$\sw{\tau}{thread A create}{thread A start}$

\item $\setSW$ relation between thread finish and thread join instructions\\
$\sw{\tau}{thread A finish}{thread A join}$

\item $\setSW$ relation between read (R) and write (W) instructions.\\
$\rf{\tau}{W_{\geq rel}x}{R_{\geq acq}x}$ $\implies$ $\sw{\tau}{W_{\geq rel}x}{R_{\geq acq}x}$\\
RMW operations are considered as both reads and writes in this case.
\end{enumerate}
Note that since we do not consider \moacq, \morel and \moar fences, 
our $\setSW$ rules do not capture them.
\par


% --------------- FIG --------------
%\begin{figure}
%\begin{center}
%	\input{section/figures-tables/hb_instr_example.tex}
%	\caption{a. Example instruction trace from CDS Checker.\\b. Adjacency table of hb relations as formed by the tool.}
%	\label{fig:cds_hb}
%\end{center}
%\end{figure}

\par
The $\setHB$ relation is computed for all instructions before inserting the 
pseudo fences in the tool. 
This way we compute the $\setHB$ for the actual input program rather than a 
modified version of program along with pseudo fences. The advantages of this
approach are two fold. First, $\setHB$ relation is only required 
to compute the $\setMO$ (modification order) relations, which is concerned only 
with the write instructions. Therefore, computing $\setHB$ relations before 
inserting pseudo fences works as an optimization. Second, if we compute $\setHB$
after inserting fences, we will have some $\setHB$ relations that are not in 
the actual execution but will exist in the execution of program with all the 
pseudo fences. \divComment{What is the problem with having such hb?}
\divComment{Rule 1b of computing TO is also using hb, but only over write operations. So the first points still holds.}

\begin{lemma} For any valid execution of a program, the relation $\setHB$ computed 
	as above is same as \emph{happens-before} of C11.
\end{lemma}

% --------------- MO ------------
\subsubsection{Finding $\setMO$ relations}
$\setMO$ relations are formed between write instructions when the value of a 
variable is changed at some point in the program. The rules for modification 
order as described by the standard \cite{C11} are:
\begin{enumerate}
    \item Write-write coherence: \\
    $\hb{\tau}{A_x}{B_x}$ $\implies$ $\mo{\tau}{A_x}{B_x}$\\
    \textit{where A, B are write operations modifying variable x}
    
    \item Read-read coherence:\\
    $\hb{\tau}{\rf{\tau}{X_x}{A_x}}{B_x}$ $\implies$ ($\rf{\tau}{X_x}{B_x}$) $\lor$\ ($\rf{\tau}{\mo{\tau}{X_x}{Y_x}}{B_x}$)\\
    \textit{where X, Y are writes on x\\ and A, B are reads on x}
    
    \item Read-write coherence:\\
    $\hb{\tau}{A_x}{B_x}$ $\implies$ ($\rf{\tau}{X_x}{A_x}$) $\land$\ ($\mo{\tau}{X_x}{B_x}$)\\
    \textit{where X, B are writes on variable x\\and A is a read on variable x}
    
    \item Write-read coherence:\\
    $\hb{\tau}{X_x}{B_x}$ $\implies$ ($\rf{\tau}{X_x}{B_x}$) $\lor$\ ($\rf{\tau}{\mo{\tau}{X_x}{Y_x}}{B_x}$)\\
    \textit{where X, Y are writes on variable x\\and B is a read on variable x}
\end{enumerate}

\begin{lemma}
	For any valid execution of a program, the relation $\setMO$ computed 
	as above is same as \emph{modification-order} of C11.
\end{lemma}

\par
After this step, the pseudo fences are inserted.

% --------------- TO -----------
\subsubsection{Finding $\setSO$ relations between SC instructions}\label{to_rel}
The final step in finding relations and the main step that is required for 
fence elimination is to find $\setSO$ relations. The rules for $\setSO$ relations 
in the C11 standard are defined in \cite{C11}. These rules can be interpreted 
as the following:
%\input{section/figures-tables/to_rules.tex}
\textit{Note: ``the fence above instruction A'' is a comprehensive term for all 
	the fences which are sequenced-before instruction A.}
Intuitively, transitive closure of $\setSO$ is \emph{sc} ordering over the 
given program execution if the program had the pseudo fences to begin with.
Such an execution may or may not be valid under C11 memory model.

\begin{theorem}
	For any valid execution of a program, the transitive closure of $\setSO$ 
	is the same as \emph{to} order of C11 of in the corresponding (possibly 
	invalid) trace with candidate fences.
\end{theorem}


% --------------- SOLN EXPLAINED -------------
\subsection{Eliminating Fences}
The rules in \textsection\ref{to_rel} provides us $\setSO$ relations between all 
instructions and fences. We now get a graph that would look 
like Fig \ref{fig:cycles}. 

%Further, the transitivity of $\setSO$ 
%relation will give us some additional pair in $\setSO$. 

\par
The purpose of creating a graph this way is to detect if there are any cycles 
formed in the trace after inserting the fences. 
In a total order 
%relation, the antisymmetry and connexity properties state that:\\
%Either \too{A}{B} or \too{B}{A} and if (\too{A}{B} $\land$ \too{B}{A}) then A = B.\\
%This property of TO can be exploited to minimize the fences. 
According to the C/C++11 standard, each \mosc instruction is in total order 
with every other \mosc instruction. This means that for any two \mosc 
instructions A and B, either $\to{\tau}{A}{B}$ or $\to{\tau}{B}{A}$. According to 
$\setSO$ rules, if both of these relations hold true, then A = B. 
If A $\neq$ B and A and B are different entities which satisfy the 
relation ($\to{\tau}{A}{B}$ $\land$ $\to{\tau}{B}{A}$), that means that a cycle is 
formed between instructions A and B. This, in turn, violates the $\setSO$ 
property, rendering the execution infeasible. If a certain execution 
becomes infeasible, then it would never exhibit during an actual execution 
of the program.

Note that apart from the rules described above, some $\setSO$ edges 
will be created due to the transitivity of $\setSO$.
We have not included these edges in our final graph and limited 
the edges in graphs to the set that was computed using the rules 
in \textsection\ref{to_rel}. That is, all $\setSB$ edges are taken into 
consideration whether immediate 
or not, and only those edges formed via the $\setSO$ rules discussed in 
section \textsection\ref{to_rel} are considered while forming a graph. 
The reason of this is explained in \textsection\ref{sec:no-transitive}.


% --------------- FIG 5 -------------------
\begin{figure}
\begin{center}
	\input{section/figures-tables/cycle_example.tex}
	\caption{A graph structure created by various relations acting as edges}
	\label{fig:cycles}
\end{center}
\end{figure}

\subsection{Restricting Buggy Executions}
\par
We find out $\setSO$ relations in only the buggy or erroneous traces which 
are obtain from verification tool. For each erroneous trace, a graph is 
formed with the instructions/fences as nodes and the $\setSO$ relations as 
edges. 
Our purpose is to insert fences such that the graph of the buggy exection 
will contain a cycle 
When such a cycle is introduced, it violates the properties of a total 
order relation in C11, rendering the entire execution infeasible. 
An infeasible execution will never occur during runtime, which means 
that the buggy execution in which the $\setSO$ cycle is introduces using 
fences will never be executed. 
Hence the assertion which was being violated will remain satisfied. 

In case there are no cycles forming for one or more of the buggy traces, 
the behavior is deemed to be unpreventable using \mosc fences. 

\par
In Fig \ref{fig:cycles}, a number of cycles can be noted. Some of them are:
\begin{itemize}
\item \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$}
\item \textit{$F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2$}
\item \textit{$F_1n_1 \rightarrow I_1n_1 \rightarrow F_2n_2 \rightarrow F_3n_2 \rightarrow F_1n_1$}
\item \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$}
\end{itemize} 
A single cycle out of the above mentioned or others being formed needs 
to be created in order to prevent this particular run from ever taking 
place. From just looking over it once, one can notice that the smallest 
cycle would be \textit{$F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2$} 
with just two participating nodes. However, the cycle with the least 
number of fences is \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow I_2n_1 
\rightarrow I_1n_1$} with just one fence (\textit{$F_2n_2$}) being inserted. 
Hence, if just \textit{$F_2n_2$} is inserted into the program, this particular 
buggy trace will be stopped. This method is carried out for all such 
buggy traces and their cycles are calculated and stored.

Another point to note is that, for each cycle, only the fences are considered
while calculating the final result. This is because the instructions present in the
cycles (if any) are already present in the input program and are immutable.
The fences, on the other hand, are the inserted by us and therefore are the only
entities considered while finding the final result.


\begin{lemma}
	Introducing fences in any cycle of $\setSO$ will stop that cycle 
	from forming in actual run of the program.
\end{lemma}

\begin{lemma}
	If there are no cycles in $\setSO$ of a buggy execution, the behavior 
	cannot be stopped using any C11 fences.
\end{lemma}

\begin{theorem}
	Stopping all cycles of $\setSO$ in any buggy execution will stop that
	buggy execution in actual run of program.
\end{theorem}

% --------------- FENCE MIN PROBLEM ----------
\subsection{The Fence Minimization Problem} \label{sec:fence-min}
\par
Even if cycles are calculated for each trace, the solution for obtaining 
a minimized number of fences to be inserted is not so straight-forward 
as simply choosing the one with the minimum fences for each trace. 
For one, there might be multiple cycles containing minimum fences. 
Another issue is that this would not yield the actual minimized 
number of fences. 

% --------------- FIG 6 -------------------
\begin{figure}
\begin{center}
	Cycles from trace 1:\\
	\textit{$F_1 \rightarrow F_2 \rightarrow I_1 \rightarrow F_1$}\\
	\textit{$F_3 \rightarrow F_4 \rightarrow F_1 \rightarrow F_3$}\\
	Cycles from trace 2:\\
	\textit{$F_3 \rightarrow F_4 \rightarrow F_3$}
	\caption{Example cycles from traces}
	\label{fig:fence_min}
\end{center}
\end{figure}

Fig \ref{fig:fence_min} shows cycles from two buggy traces from 
a program. 
one solution to obtain the minimum number of fences was 
to take the smallest cycle from each trace, that is to take the 
cycle which contains the least number of fences from each execution 
trace. In this case, fences \textit{$F_1$}, \textit{$F_2$} 
would be chosen from trace 1 and fences \textit{$F_3$}, \textit{$F_4$} 
would be chosen from trace 2. This makes four total fences that 
to include in the main program to stop the behavior where 
any assertion gets violated.

\par
However, this is not the optimal solution. Fig \ref{fig:fence_form} 
shows the example explained in Fig \ref{fig:fence_min} converted 
into its respective formula in propositional logic. For each trace, 
the cycles are added as disjunctions, with each fence in a cycle 
being a necessary component, deeming it a conjunction. Since each 
trace needs to satisfy at least one cycle for the trace to become 
infeasible, each cycle is a disjunction. All traces need to be 
prevented, so each trace is part of a conjunction. Let 
$ \mathcal{B} $ be the set of all buggy execution of a program with 
at least one cycle. Let $ \mathcal{F}(\mathcal{B}) $ gives the 
fence minimization formula for set of buggy executions $ \mathcal{B} $.

% --------------- FIG 7 -----------------
\begin{figure}
\begin{center}
	( ( $F_1 \land F_2\ ) \lor\ ( F_3 \land F_4 \land F_1\ )\ ) \land\ (\ (\ F_3 \land F_4$ ) )
	\caption{Formula for Fig \ref{fig:fence_min}}
	\label{fig:fence_form}
\end{center}
\end{figure}

\par
The formula in fig \ref{fig:fence_form} can be looked at as a 
cost function to minimize the cost, with each entity being a fence, 
having value either 0 or 1. A fence having value 1 would mean that 
it should be inserted in the program and value 0 would mean that 
it should not be inserted in the program, according to the 
minimized cost. From this formula, the solution for Fig \ref{fig:fence_min} 
comes out to have 3 fences â€“ \textit{$F_3, F_4, F_1$}, 
unlike the original solution where four fences were sought.

\begin{theorem}
	For any input program $ \mathcal{F}(\mathcal{B}) $ gives optimal
	number of fences required to stop all the buggy behaviors in 
	$ \mathcal{B} $.
\end{theorem}

\par
Implementing such a propostional formula for programs with 
more than 50 execution traces, with each of them having uncountable 
fences would be quite an overhead. An SMT/SAT Solver is used for 
this purpose. Our tool uses Z3 to find minimum satisfying assignment 
of such formulas. A formula similar to the one in Fig \ref{fig:fence_form} 
is created for each program and the minimum cost with the maximum 
satisfying assignment is computed. 

\input{section/figures-tables/algo_figure.tex}


\subsubsection{why transitive TO edges aren't considered} \label{sec:no-transitive}
The relations which are considered to form the final graph are - 
all $\setSB$ edges between only \mosc instructions including transitive $\setSB$ edges, 
and directly formed $\setSO$ edges but not transitively formed $\setSO$ edges.  
This is because transitively formed $\setSO$ relations will be of 
no use in our case. If there is a transitive $\setSO$ relation formed 
between two instructions, then this relation has been caused by 
some other edges in our graph. 
Our formula is concerned only with the cycles in the graph 
(as discussed in \textsection\ref{sec:fence-min}), we will focus on 
the new cycles that might come if we were to consider the transitive 
edges. These cycles might be formed because of two reasons - 
either the new cycle consists of i) some transitive edges in the 
actual program that we did not include in $\setSO$, or ii) some 
transitive edges created due to pseudo fences. In case i), the cycle 
(let $C$) is certainly caused by some pseudo fence inserted in the program 
since the actual program execution cannot have a cycle. Since the 
transitive edge is formed due to some edge in our $\setSO$, there 
will be a representative cycle $C'$ of the cycle $C$ formed using 
edges in $\setSO$. As our formula only concerns the pseudo fences, 
the formula constructed for $C$ and $C'$ will be the same. 
Similarly in case ii), since the cycle is created due to transitive 
edge caused by one or more fences, the formula must consist these 
fences too as a way to determine which fences caused the cycle. Hence,
the formula remains same. 

%Even if we were to consider these edges, the formula will not change. 
%Therefore, for this transitive 
%relation, we need not consider the two nodes participating in the 
%transitive edge, instead we need to consider the original nodes 
%which caused this transitive relation to form in the first place. 
%Transitive edges are formed through transitive relations which will 
%hide the originally formed TO relations. But by excluding the 
%original edges, the transitive edges we need will never actually be formed.

For instance, look at Fig \ref{fig:cycles}. The edge \textit{$F_3n_2$} 
$\rightarrow$ \textit{$I_1n_1$} is not an edge found through the rules of 
TO relations. It is a transitive edge. So if we were to consider the cycle 
\textit{$F_3n_2$} $\rightarrow$ \textit{$I_1n_1$} $\rightarrow$ \textit{$F_2n_2$}
$\rightarrow$ \textit{$F_3n_2$}, we notice that the edge \textit{$F_3n_2$} 
$\rightarrow$ \textit{$I_1n_1$} cannot exist on its own. Hence we cannot simply 
consider the three edges which partake in the formation of this cycle.
We will need to consider all the possible edges which caused the formation of the 
transitive edge, which are:
\begin{enumerate}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_2n_2$} $\rightarrow$ 
\textit{$I_2n_1$} $\rightarrow$ \textit{$I_1n_1$}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_1n_1$} $\rightarrow$ \textit{$I_1n_1$}
\end{enumerate}

Hence the cycle \textit{$F_3n_2$} $\rightarrow$ \textit{$I_1n_1$} $\rightarrow$
\textit{$F_2n_2$} $\rightarrow$ \textit{$F_3n_2$} translates into the following cycles:
\begin{enumerate}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_2n_2$} $\rightarrow$ \textit{$I_2n_1$} 
$\rightarrow$ \textit{$I_1n_1$} $\rightarrow$ \textit{$F_2n_2$} $\rightarrow$ \textit{$F_3n_2$}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_1n_1$} $\rightarrow$ \textit{$I_1n_1$} $\rightarrow$
\textit{$F_2n_2$} $\rightarrow$ \textit{$F_3n_2$}
\end{enumerate}


\par
So even if transitive $\setSO$ relations are considered as graph edges, 
they would not impact our final solution. 
%For each transitively 
%formed edge, all original edges which would have possibly caused 
%the transitive edge would be needed to be kept track of. 
Therefore, using just the original edges serves our purpose 
in a much more efficient manner.