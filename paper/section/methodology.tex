% --------- INTRO PART -------------
We have developed a novel solution to the fence-synthesis problem. 
To the best of our knowledge, 
there are no push-button fence synthesis techniques for C11 
programs as of now. Although, there are some such techniques for 
other memory models, all of those heavily depends on the 
possible set of reorderings allowed under the memory model. 
Since the possible set of reorderings under C11 is different 
than other memory models, these techniques cannot be applied 
to C11 as is. In face, not all C11 behaviors can be justified 
using reorderings and interleavings. Hence, automatic fence insertion 
for C11 requires some amount of additional effort.
We use the C11 semantics to create relations between the 
instructions and exploit the properties of these relations. 
The C11 semantics require that there should be a total 
order among all \mosc operations in the programs. We leverage this to 
find program locations for candidate \mosc fence placements. We achieve 
the optimal results by converting the candidate fence placements to 
SMT formula and querying the Z3 SMT solver.

The tool first begins by analyzing the input program through a C11 model 
checker or verification tool. This tool runs all possible executions of 
the program and gives a list of buggy traces as output. A buggy trace 
here means an execution run where an assertion was violated in the program. 
The model checker provides the exact order of instructions, which when 
executed in the order can cause the program to stop mid-way by running 
into an assertion and not being able to satisfy it. The verification 
tool also provides the meta data for each instruction, such as read-from 
values, memory orders and line number in the actual program.

In the program described in Fig \ref{fig:dekker2}, inserting an SC fence 
between the instructions (1) and (2), and an SC fence between (5) and (6) 
render the program non-buggy, thereby satisfying the given assertions. 
After adding these fences, the program will never have a case where 
the output can be anything other than ``10''. 

To obtain the position of these fences, a series of steps is followed. 
The two fences strategically inserted in the program are the minimum 
number of fences which can be inserted in order to prevent the unwanted 
outputs. \snj{Not correct: 
	One can add \mosc fences at all positions - before and after all 
instructions - in order to make the program as strict as possible under 
C11} and hence prevent the buggy outputs if possible, such as in Fig 
\ref{fig:dekker3}. However, this comes at the cost of making program 
stricter than required. Therefore, in our solution to retain maximum 
flexibility, after inserting fences at all places, we must now eliminate 
the ones which are not required and bring the number of fences down to 
an optimum or minimum. To do this, we need to find relations between 
all instructions and understand their semantics.

The reason for choosing \mosc fences is that they are the strongest type 
of fences, as seen in Fig \ref{fig:mo_strength}. In the program described 
in Fig \ref{fig:dekker3}, the \moacqrel fences cannot stop the buggy behavior.

Another point to note is, inserting \mosc fences at all possible program 
locations might not mean that the buggy behaviors are eliminated. 
Therefore, our tool can only prevent the assertions from being violated 
in cases where the behavior can be stopped using \mosc fences. Note that
if a trace cannot be stopped by \mosc fence, then no C11 fence can stop 
the trace. The tool also serves to minimize the total number of fences to 
be added to the optimal number, thereby retaining the program behaviors 
as relaxed as possible.

% --------------- FIG all pseudo fences -------------
\begin{figure}[!htb]
\begin{center}
\texttt{
init y := 0, x := 0;\\
	\begin{tabular}{c l || c l}
		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
		(1) & W$\mathtt{_{rel}}$y(1) & (5) & W$\mathtt{_{rel}}$x(1)\\
		& F$\mathtt{_{sc}}$ & & F$\mathtt{_{sc}}$\\
		(2) & if R$\mathtt{_{rel}x}$ == 0 & (6) & if R$\mathtt{_{rel}y}$ == 0\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
		(3) & \qquad W$\mathtt{_{rel}}$c(1) & (7) & \qquad W$\mathtt{_{rel}}$c(0)\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
		(4) & \qquad assert($\mathtt{R_{rel}c}$ == 1) & (8) & \qquad assert($\mathtt{R_{rel}c}$ == 0)\\
		& \qquad F$\mathtt{_{sc}}$ & & \qquad F$\mathtt{_{sc}}$\\
	\end{tabular}
}
	\caption{Simple two-thread dekker program in C11 syntax with fences at each location}\label{fig:dekker3}
\end{center}
\end{figure}

% --------- ADDING FENCES -------------
\subsection{Adding Pseudo Fences}
\par
We use a verification tool to generate a set of all the buggy traces. 
Each trace is then taken individually and analyzed. For each trace, 
the first step is inserting pseudo fences. \mosc fences are inserted 
before/after each instruction in the trace. This can be seen in 
Fig. \ref{fig:dekker3}. The fences are not actually added to the 
input program, but only added for reference purposes as a step in 
the tool. The maximum number of fences possible are added so that 
the required ones can be retained and the rest can be eliminated.

% --------------- FINDING RELATIONS -----------
\subsection{Finding relations}
% What is TO?
The C11 standard \cite{C11} states that in any valid execution 
all the \mosc instructions should form a total order. Such total order
has to be consistent with modification order and 
happens-before relation. This means that for any two \mosc instructions A 
and B such that A $ \neq B $, either \too{A}{B} or \too{B}{A}. 
Hence, an execution with both \too{A}{B} and \too{B}{A} is infeasible.
% Why TO?
Our technique computes \setTO of buggy execution when pseudo fences are 
present. If such \setTO has a cycle, then the program with these fences 
will not have this buggy execution. 
Hence, by finding these cycles we can work out the required fences.
% Example
For example, in Fig \ref{fig:dekker2}, if the assert statement is violated
if either thread reads the value written to variable $c$ by the other thread.
% Other relations
%In order to find \setTO, we first compute the \setSB, \setSW, \setHB and 
%\setMO relations.
The basis of our approach lies upon finding relations between the 
instructions and figuring out how they affect the program in order to 
reduce the total fences to a minimum. 

\par
The next step after inserting pseudo fences is finding relations between 
instructions, including fences. 
These relations will help in figuring out which fences to eliminate from 
the trace. In particular, we are concerned with the \setTO (total order) 
relations between all SC instructions and fences. Rules for TO relations 
for the C11 model are described in the official standard \cite{C11}. 
These rules are dependent relations \setSB, \setSW, \setHB and \setMO, which 
would have to be computed first, and an order is followed for the same.

% --------------- HB -----------------
\subsubsection{Finding \setHB relations}
The first and most basic relation is \setHB (happens-before). 
An instruction A is said to happen-before B if:\\
(\sw{A}{B}) $\lor$ (\seqb{A}{B}) $\lor$ (\hb{A}{X} $\land$ \hb{X}{B}) $\implies$ \hb{A}{B}

\par
Therefore, \setSB (sequenced-before) and \setSW (synchronizes-with) 
relations are computed first. 
An \setSW relation is formed based on the following rules:
\begin{enumerate}
\item \setSW relation between thread create and thread start instructions\\
\sw{thread A create}{thread A start}

\item \setSW relation between thread finish and thread join instructions\\
\sw{thread A finish}{thread A join}

\item \setSW relation between read (R) and write (W) instructions.\\
\rf{$W_{\geq rel}x$}{$R_{\geq acq}x$} $\implies$ \sw{$W_{\geq rel}x$}{$R_{\geq acq}x$}\\
RMW operations are considered as both reads and writes in this case.
\end{enumerate}

\par


% --------------- FIG --------------
%\begin{figure}
%\begin{center}
%	\input{section/hb_instr_example.tex}
%	\caption{a. Example instruction trace from CDS Checker.\\b. Adjacency table of hb relations as formed by the tool.}
%	\label{fig:cds_hb}
%\end{center}
%\end{figure}

\par
The \setHB relation is computed for all instructions before inserting the 
pseudo fences in the tool. 
This way we compute the \setHB for the actual input program rather than a 
modified version of program along with pseudo fences. The advantages of this
approach are two fold. First, \setHB relation is only required 
to compute the \setMO (modification order) relations, which is concerned only 
with the write instructions. Therefore, computing \setHB relations before 
inserting pseudo fences works as an optimization. Second, if we compute \setHB
after inserting fences, we will have some \setHB relations that are not in 
the actual execution but will exist in the execution of program with all the 
pseudo fences. \divComment{Why can't we compute it after?}

% --------------- MO ------------
\subsubsection{Finding \setMO relations}
\setMO relations are formed between write instructions when the value of a 
variable is changed at some point in the program. The rules for modification 
order as described by the standard \cite{C11} are:
\begin{enumerate}
    \item Write-write coherence: \\
    \hb{$A_x$}{$B_x$} $\implies$ \mo{$A_x$}{$B_x$}\\
    \textit{where A, B are write operations modifying variable x}
    
    \item Read-read coherence:\\
    \hb{\rf{$X_x$}{$A_x$}}{$B_x$} $\implies$ (\rf{$X_x$}{$B_x$}) $\lor$\ (\rf{\mo{$X_x$}{$Y_x$}}{$B_x$})\\
    \textit{where X, Y are writes on x\\ and A, B are reads on x}
    
    \item Read-write coherence:\\
    \hb{$A_x$}{$B_x$} $\implies$ (\rf{$X_x$}{$A_x$}) $\land$\ (\mo{$X_x$}{$B_x$})\\
    \textit{where X, B are writes on variable x\\and A is a read on variable x}
    
    \item Write-read coherence:\\
    \hb{$X_x$}{$B_x$} $\implies$ (\rf{$X_x$}{$B_x$}) $\lor$\ (\rf{\mo{$X_x$}{$Y_x$}}{$B_x$})\\
    \textit{where X, Y are writes on variable x\\and B is a read on variable x}
\end{enumerate}

\par
After this step, the pseudo fences are inserted.

% --------------- TO -----------
\subsubsection{Finding \setTO relations between SC instructions}\label{to_rel}
The final step in finding relations and the main step that is required for 
fence elimination is to find \setTO relations. The rules for \setTO relations 
in the C11 standard are defined in \cite{C11}. These rules can be interpreted 
as the following:
\input{section/to_rules.tex}
\textit{Note: ``the fence above instruction A'' is a comprehensive term for all 
	the fences which are sequenced-before instruction A.}


% --------------- SOLN EXPLAINED -------------
\subsection{Eliminating Fences}
The rules in \textsection\ref{to_rel} provides us \setTO relations between all 
instructions and fences. We now get a graph that would look 
like Fig \ref{fig:cycles}. 

%Further, the transitivity of \setTO 
%relation will give us some additional pair in \setTO. 

\par
The purpose of creating a graph this way is to detect if there are any cycles 
formed in the trace after inserting the fences. 
In a total order 
%relation, the antisymmetry and connexity properties state that:\\
%Either \too{A}{B} or \too{B}{A} and if (\too{A}{B} $\land$ \too{B}{A}) then A = B.\\
%This property of TO can be exploited to minimize the fences. 
According to the C/C++11 standard, each \mosc instruction is in total order 
with every other \mosc instruction. This means that for any two \mosc 
instructions A and B, either \too{A}{B} or \too{B}{A}. According to 
\setTO rules, if both of these relations hold true, then A = B. 
If A $\neq$ B and A and B are different entities which satisfy the 
relation (\too{A}{B} $\land$ \too{B}{A}), that means that a cycle is 
formed between instructions A and B. This, in turn, violates the \setTO 
property, rendering the execution infeasible. If a certain execution 
becomes infeasible, then it would never exhibit during an actual execution 
of the program.

Note that apart from the rules described above, some \setTO edges 
will be created due to the transitivity of \setTO.
We have not included these edges in our final graph and limited 
the edges in graphs to the set that was computed using the rules 
in \textsection\ref{to_rel}. That is, all \setSB edges are taken into 
consideration whether immediate 
or not, and only those edges formed via the \setTO rules discussed in 
section \textsection\ref{to_rel} are considered while forming a graph. 
The reason of this is explained in \textsection\ref{sec:no-transitive}.


% --------------- FIG 5 -------------------
\begin{figure}
\begin{center}
	\input{section/cycle_example.tex}
	\caption{A graph structure created by various relations acting as edges}
	\label{fig:cycles}
\end{center}
\end{figure}

\subsection{Restricting Buggy Executions}
\par
We find out \setTO relations in only the buggy or erroneous traces which 
are obtain from verification tool. For each erroneous trace, a graph is 
formed with the instructions/fences as nodes and the \setTO relations as 
edges. 
Our purpose is to insert fences such that the graph of the buggy exection 
will contain a cycle 
When such a cycle is introduced, it violates the properties of a total 
order relation in C11, rendering the entire execution infeasible. 
An infeasible execution will never occur during runtime, which means 
that the buggy execution in which the \setTO cycle is introduces using 
fences will never be executed. 
Hence the assertion which was being violated will remain satisfied. 

In case there are no cycles forming for one or more of the buggy traces, 
the behavior is deemed to be unpreventable using \mosc fences. 

\par
In Fig \ref{fig:cycles}, a number of cycles can be noted. Some of them are:
\begin{itemize}
\item \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$}
\item \textit{$F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2$}
\item \textit{$F_1n_1 \rightarrow I_1n_1 \rightarrow F_2n_2 \rightarrow F_3n_2 \rightarrow F_1n_1$}
\item \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2 \rightarrow I_2n_1 \rightarrow I_1n_1$}
\end{itemize} 
A single cycle out of the above mentioned or others being formed needs 
to be created in order to prevent this particular run from ever taking 
place. From just looking over it once, one can notice that the smallest 
cycle would be \textit{$F_2n_2 \rightarrow F_3n_2 \rightarrow F_2n_2$} 
with just two participating nodes. However, the cycle with the least 
number of fences is \textit{$I_1n_1 \rightarrow F_2n_2 \rightarrow I_2n_1 
\rightarrow I_1n_1$} with just one fence (\textit{$F_2n_2$}) being inserted. 
Hence, if just \textit{$F_2n_2$} is inserted into the program, this particular 
buggy trace will be stopped. This method is carried out for all such 
buggy traces and their cycles are calculated and stored.

Another point to note is that, for each cycle, only the fences are considered
while calculating the final result. This is because the instructions present in the
cycles (if any) are already present in the input program and are immutable.
The fences, on the other hand, are the inserted by us and therefore are the only
entities considered while finding the final result.

% --------------- FENCE MIN PROBLEM ----------
\subsection{The Fence Minimization Problem} \label{sec:fence-min}
\par
Even if cycles are calculated for each trace, the solution for obtaining 
a minimized number of fences to be inserted is not so straight-forward 
as simply choosing the one with the minimum fences for each trace. 
For one, there might be multiple cycles containing minimum fences. 
Another issue is that this would not yield the actual minimized 
number of fences. 

% --------------- FIG 6 -------------------
\begin{figure}
\begin{center}
	Cycles from trace 1:\\
	\textit{$F_1 \rightarrow F_2 \rightarrow I_1 \rightarrow F_1$}\\
	\textit{$F_3 \rightarrow F_4 \rightarrow F_1 \rightarrow F_3$}\\
	Cycles from trace 2:\\
	\textit{$F_3 \rightarrow F_4 \rightarrow F_3$}
	\caption{Example cycles from traces}
	\label{fig:fence_min}
\end{center}
\end{figure}

Fig \ref{fig:fence_min} shows cycles from two buggy traces from 
a program. 
one solution to obtain the minimum number of fences was 
to take the smallest cycle from each trace, that is to take the 
cycle which contains the least number of fences from each execution 
trace. In this case, fences \textit{$F_1$}, \textit{$F_2$} 
would be chosen from trace 1 and fences \textit{$F_3$}, \textit{$F_4$} 
would be chosen from trace 2. This makes four total fences that 
to include in the main program to stop the behavior where 
any assertion gets violated.

\par
However, this is not the optimal solution. Fig \ref{fig:fence_form} 
shows the example explained in Fig \ref{fig:fence_min} converted 
into its respective formula in propositional logic. For each trace, 
the cycles are added as disjunctions, with each fence in a cycle 
being a necessary component, deeming it a conjunction. Since each 
trace needs to satisfy at least one cycle for the trace to become 
infeasible, each cycle is a disjunction. All traces need to be 
prevented, so each trace is part of a conjunction.

% --------------- FIG 7 -----------------
\begin{figure}
\begin{center}
	( ( $F_1 \land F_2\ ) \lor\ ( F_3 \land F_4 \land F_1\ )\ ) \land\ (\ (\ F_3 \land F_4$ ) )
	\caption{Formula for Fig \ref{fig:fence_min}}
	\label{fig:fence_form}
\end{center}
\end{figure}

\par
The formula in fig \ref{fig:fence_form} can be looked at as a 
cost function to minimize the cost, with each entity being a fence, 
having value either 0 or 1. A fence having value 1 would mean that 
it should be inserted in the program and value 0 would mean that 
it should not be inserted in the program, according to the 
minimized cost. From this formula, the solution for Fig \ref{fig:fence_min} 
comes out to have 3 fences â€“ \textit{$F_3, F_4, F_1$}, 
unlike the original solution where four fences were sought.

\par
Implementing such a propostional formula for programs with 
more than 50 execution traces, with each of them having uncountable 
fences would be quite an overhead. An SMT/SAT Solver is used for 
this purpose. Our tool uses Z3 to find minimum satisfying assignment 
of such formulas. A formula similar to the one in Fig \ref{fig:fence_form} 
is created for each program and the minimum cost with the maximum 
satisfying assignment is computed. 

\input{section/algo_figure.tex}


\subsubsection{why transitive TO edges aren't considered} \label{sec:no-transitive}
The relations which are considered to form the final graph are - 
all \setSB edges between only \mosc instructions including transitive \setSB edges, 
and directly formed \setTO edges but not transitively formed \setTO edges.  
This is because transitively formed \setTO relations will be of 
no use in our case. If there is a transitive \setTO relation formed 
between two instructions, then this relation has been caused by 
some other edges in our graph. 
Our formula is concerned only with the cycles in the graph 
(as discussed in \textsection\ref{sec:fence-min}), we will focus on 
the new cycles that might come if we were to consider the transitive 
edges. These cycles might be formed because of two reasons - 
either the new cycle consists of i) some transitive edges in the 
actual program that we did not include in \setTO, or ii) some 
transitive edges created due to pseudo fences. In case i), the cycle 
(let $C$) is certainly caused by some pseudo fence inserted in the program 
since the actual program execution cannot have a cycle. Since the 
transitive edge is formed due to some edge in our \setTO, there 
will be a representative cycle $C'$ of the cycle $C$ formed using 
edges in \setTO. As our formula only concerns the pseudo fences, 
the formula constructed for $C$ and $C'$ will be the same. 
Similarly in case ii), since the cycle is created due to transitive 
edge caused by one or more fences, the formula must consist these 
fences too as a way to determine which fences caused the cycle. Hence,
the formula remains same. 

%Even if we were to consider these edges, the formula will not change. 
%Therefore, for this transitive 
%relation, we need not consider the two nodes participating in the 
%transitive edge, instead we need to consider the original nodes 
%which caused this transitive relation to form in the first place. 
%Transitive edges are formed through transitive relations which will 
%hide the originally formed TO relations. But by excluding the 
%original edges, the transitive edges we need will never actually be formed.

For instance, look at Fig \ref{fig:cycles}. The edge \textit{$F_3n_2$} 
$\rightarrow$ \textit{$I_1n_1$} is not an edge found through the rules of 
TO relations. It is a transitive edge. So if we were to consider the cycle 
\textit{$F_3n_2$} $\rightarrow$ \textit{$I_1n_1$} $\rightarrow$ \textit{$F_2n_2$}
$\rightarrow$ \textit{$F_3n_2$}, we notice that the edge \textit{$F_3n_2$} 
$\rightarrow$ \textit{$I_1n_1$} cannot exist on its own. Hence we cannot simply 
consider the three edges which partake in the formation of this cycle.
We will need to consider all the possible edges which caused the formation of the 
transitive edge, which are:
\begin{enumerate}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_2n_2$} $\rightarrow$ 
\textit{$I_2n_1$} $\rightarrow$ \textit{$I_1n_1$}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_1n_1$} $\rightarrow$ \textit{$I_1n_1$}
\end{enumerate}

Hence the cycle \textit{$F_3n_2$} $\rightarrow$ \textit{$I_1n_1$} $\rightarrow$
\textit{$F_2n_2$} $\rightarrow$ \textit{$F_3n_2$} translates into the following cycles:
\begin{enumerate}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_2n_2$} $\rightarrow$ \textit{$I_2n_1$} 
$\rightarrow$ \textit{$I_1n_1$} $\rightarrow$ \textit{$F_2n_2$} $\rightarrow$ \textit{$F_3n_2$}
	\item \textit{$F_3n_2$} $\rightarrow$ \textit{$F_1n_1$} $\rightarrow$ \textit{$I_1n_1$} $\rightarrow$
\textit{$F_2n_2$} $\rightarrow$ \textit{$F_3n_2$}
\end{enumerate}


\par
So even if transitive \setTO relations are considered as graph edges, 
they would not impact our final solution. 
%For each transitively 
%formed edge, all original edges which would have possibly caused 
%the transitive edge would be needed to be kept track of. 
Therefore, using just the original edges serves our purpose 
in a much more efficient manner.